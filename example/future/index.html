<!DOCTYPE html>
<html lang="en">
<head>
    <title>ui-router-extras FutureState demo</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <script type="text/javascript" src="../../js/ga.js"></script>
    <link href="../../css/bootstrap.css" rel="stylesheet">
    <link href="../../css/statevis.css" rel="stylesheet">
    <link href="style.css" rel="stylesheet">
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/d3/3.4.8/d3.js"></script>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/underscore.js/1.6.0/underscore-min.js"></script>
    <script type="text/javascript" data-main="main.js" src="//cdnjs.cloudflare.com/ajax/libs/require.js/2.1.11/require.js"></script>
</head>

<body>

<div class="navbar navbar-default navbar-static-top" role="navigation">
    <ul class="nav navbar-nav">
        <li><a href="../../#/future/">Back to UI-Router Extras</a></li>
        <li ng-class="{active: $state.includes('iframe1')}"><a href="#/iframe1">IFrame 1</a></li>
        <li ng-class="{active: $state.includes('iframe2')}"><a href="#/iframe2">IFrame 2</a></li>
        <li ng-class="{active: $state.includes('module1')}"><a href="#/module1">Module 1</a></li>
        <li ng-class="{active: $state.includes('module2')}"><a href="#/module2">Module 2</a></li>
        <li><a ui-sref="module2">Module 2 via ui-sref</a></li>
    </ul>
</div>
<div class="container text-center">
    <h3> Open your browser's debugger tools. </h3>
    
</div>
<div  class="container">
    <div class="col-sm-6">
        <p> When this page loads, it has no states registered with ui-router $stateProvider. </p>
        <p> FutureState objects are loaded from futureStates.json using $http service after the configuration phase. </p>
        <p> The four links above go to future state mappings.  When navigating to a link, the StateFactory promises
            to make a full ui-router state.  When the state is fully resolved, the navigation is re-attempted.</p>
        <p> Two of the FutureStates are of type 'iframe', and two are 'ngload'.</p>
        <p>The 'iframe' states are created from a StateFactory that simply sets the template to an iframe using the FutureState's src attribute.</p>
        <button class='btn btn-info' ng-click="showhide.iframefactory = !showhide.iframefactory">Show/Hide iframeStateFactory source</button>
        <br><br>
        <div ng-cloak class="ng-cloak panel panel-info" ng-show="showhide.iframefactory">
            <div class="panel-heading">
                <code>iframeStateFactory</code> source code.
            </div>
            <div class="panel-body">
<pre>var iframeStateFactory = function($q, futureState) {
  var state = {
    name: futureState.stateName,
    template: "&lt;iframe src='" + futureState.src + "'&gt;&lt;/iframe&gt;",
    url: futureState.urlPrefix
  };
  return $q.when(state);
};</pre>
                <p> 
                    This function takes a <code>FutureState</code> object and creates a state with an iframe template.
                    This is simply showing how full UI-Router <code>state</code> objects are created from
                    <code>FutureState</code> objects, and how you can add injectables.
                </p>
            </div>
        </div>
        <p> The 'ngload' states are created from a StateFactory that uses RequireJS and AngularAMD to dynamically 
            load a standalone module's JS source. </p>
        <button class='btn btn-info' ng-click="showhide.ngloadfactory = !showhide.ngloadfactory">Show/Hide ngloadStateFactory source</button>
        <br><br>
        <div ng-cloak class="ng-cloak panel panel-info" ng-show="showhide.ngloadfactory">
            <div class="panel-heading">
                <code>ngloadStateFactory</code> source code.
            </div>
            <div class="panel-body">
<pre>function ngloadStateFactory($q, futureState) {
  var ngloadDeferred = $q.defer();
  require([ "ngload!" + futureState.src , 'ngload', 'angularAMD'],  
      function ngloadCallback(result, ngload, angularAMD) {
    angularAMD.processQueue();
    ngloadDeferred.resolve(result.entryState);
  });
  return ngloadDeferred.promise;
}</pre>
                <p>
                    This state factory takes an 'ngload' <code>FutureState</code> definition, then calls RequireJS using
                    the AngularAMD 'ngload' plugin for <code>futureState.src</code>.  In this example, <code>futureState.src</code>
                    will be set to module1.js or module2.js.
                </p>
                
                <p>
                    RequireJS loads the module1.js source code.  AngularAMD routes module1.js <code>angular.config</code>,
                    <code>angular.controller</code>, etc function calls through its  function proxy code to the angular
                    config time registration methods.</p>
                <p>
                    Module1.js registers its states/controllers, then returns a reference to the module and the module's
                    entry point state ('module1').  </p>
                <p>
                    The module and entry point state is returned to RequireJS, then the ngloadstateFactory callback is called 
                    and the promise is resolved with the entry point state..
                </p>
                <p> Then, $futureStateProvider retries the transition. </p>
            </div>
        </div>
    </div>
    
    
    
    <div class="col-sm-6">
        
    <div width="300" height="200" state-vis></div>
    <div class="content" ui-view>
        <!-- State views load here -->
        <small>States' views will load here.</small>
    </div>
    </div>
</div>

</body>
</html>
